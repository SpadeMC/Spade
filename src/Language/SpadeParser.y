{
{-|
Module      : SpadeParser
Description : Parser for Spade
Copyright   : (c) Josh Findon and Edward Jones, 2019
License     : MIT
Maintainer  : Josh Findon and Edward Jones
Stability   : experimental
Portability : POSIX + Windows
Language    : Haskell2010

This module defines the machinery to parse Spade from a token stream generated by the lexer.
-}
module Language.SpadeParser (parseSpade) where

import Language.AST
import Language.SpadeLexer (Alex, AlexPosn(..), Token(..), lexWrap, alexError, runAlex)
import Language.Position (GetPos, getPos)

}

%name parseSpade ast
%name parseREPL moduleItem

%error { parseError }
%lexer { lexWrap } { TEoF }
%monad { Alex }
%tokentype { Token }

-- Enforce perfection
%expect 0

%token
    BOOL            { TBool                 isTrue p }
    IDENT           { TIdent                identifierVal p }
    INT             { TInteger              intVal p }
    REAL            { TReal                 realVal p }
    STRING          { TString               stringVal p }
    LINE_COMMENT    { TLineComment          p }
    ":"             { TColon                p }
    "}"             { TBlockSeparator       p }
    "{"             { TBlockStarter         p }
    "\n"            { TPartSeparator        p }
    "("             { TLParenth             p }
    ")"             { TRParenth             p }
    "["             { TLBracket             p }
    "]"             { TRBracket             p }
    ".."            { TRange                p }
    ","             { TComma                p }
    "."             { TDot                  p }
    "|"             { TSeqCont              p }
    "|-"            { TSeqSeries            p }
    "|>"            { TSeqStart             p }
    "bool"          { TBoolT                p }
    "real"          { TRealT                p }
    "int"           { TIntT                 p }
    "string"        { TStringT              p }
    "case"          { TCase                 p }
    "else"          { TElse                 p }
    "if"            { TIf                   p }
    "for"           { TFor                  p }
    "in"            { TIn                   p }
    "repeat"        { TRepeat               p }
    "while"         { TWhile                p }
    "return"        { TReturn               p }
    "="             { TGets                 p }
    "<=="           { TNBTMove              p }
    "><"            { TSwap                 p }
    "$"             { TConstant             p }
    "~"             { TPure                 p }
    "->"            { TGoesTo               p }
    "=="            { TEqual                p }
    "!="            { TNotEqual             p }
    "<"             { TLessThan             p }
    "<="            { TLessThanOrEqual      p }
    ">"             { TGreaterThan          p }
    ">="            { TGreaterThanOrEqual   p }
    ">"             { TRAngle               p }
    "/"             { TMax                  p }
    "/"             { TMin                  p }
    "&"             { TAnd                  p }
    "!"             { TNot                  p }
    "|"             { TOr                   p }
    "/"             { TCommand              p }
    "/"             { TDivide               p }
    "+"             { TPlus                 p }
    "-"             { TMinus                p }
    "*"             { TTimes                p }
    "%"             { TModulo               p }
    "<"             { TLAngle               p }
    -- DOCASSIGNMENTLINE   { TDocAssignmentLine    p }
    -- DOCLINE             { TDocLine              p }
    -- INT                 { TInteger              intVal p }
    -- BOOL                { TBool                 isTrue p }
    -- REAL                { TReal                 realVal p }
    -- CHAR                { TChar                 charVal p }
    -- STRING              { TString               stringVal p }
    -- "if"                { TIf                   p }
    -- "else"              { TElse                 p }
    -- "while"             { TWhile                p }
    -- "repeat"            { TRepeat               p }
    -- "with"              { TWith                 p }
    -- "switch"            { TSwitch               p }
    -- "for"               { TFor                  p }
    -- "import"            { TImport               p }
    -- "module"            { TModule               p }
    -- IDENT               { TIdent                identifierVal p }
    -- "<-"                { TQueue                p }
    -- "->"                { TGoesTo               p }
    -- "="                 { TGets                 p }
    -- "("                 { TLParenth             p }
    -- ")"                 { TRParenth             p }
    -- "["                 { TLBracket             p }
    -- "]"                 { TRBracket             p }
    -- "{"                 { TLBrace               p }
    -- "}"                 { TRBrace               p }
    -- "+"                 { TPlus                 p }
    -- "-"                 { TMinus                p }
    -- "/"                 { TDivide               p }
    -- "%"                 { TModulo               p }
    -- "*"                 { TTimes                p }
    -- "<<"                { TShiftLeft            p }
    -- ">>"                { TShiftRight           p }
    -- ">>>"               { TShiftRightSameSign   p }
    -- "&"                 { TAndScrict            p }
    -- "&&"                { TAndLazy              p }
    -- "|"                 { TOrStrict             p }
    -- "||"                { TOrLazy               p }
    -- "!"                 { TNot                  p }
    -- "^"                 { TXor                  p }
    -- "<"                 { TLessThan             p }
    -- "<="                { TLessThanOrEqual      p }
    -- ">"                 { TGreaterThan          p }
    -- ">="                { TGreaterThanOrEqual   p }
    -- "=>"                { TImplies              p }
    -- "=="                { TEqual                p }
    -- "!="                { TNotEqual             p }
    -- "@"                 { TImpure               p }
    -- ","                 { TComma                p }
    -- ":"                 { TColon                p }
    -- ";"                 { TPartSeparator        p }
    -- "int"               { TIntT                 p }
    -- "bool"              { TBoolT                p }
    -- "real"              { TRealT                p }
    -- "char"              { TCharT                p }
    -- "string"            { TStringT              p }
    -- "()"                { TUnit                 p }
    -- "Any"               { TAnyT                 p }
    -- "<:"                { TIsSubType            p }
    -- "<~"                { TIsImplementeBy       p }
    -- "|>"                { TIsType               p }
    -- "class"             { TClass                p }
    -- "component"         { TComponent            p }
    -- "#"                 { TBlockSeparator       p }
    -- "return"            { TReturn               p }

%left CALL
%right "->"
%left "|"
%left "&"
%left "==" "!="
%left "<" "<=" ">" ">="
%left "+" "-"
%left "*" "/" "%"
%right NEG "!"
%right "$" "~"
%nonassoc "{" "[" "(" INT REAL CHAR BOOL IDENT STRING

%%

ast :: {AST}
ast : moduleItems   { AST $1 }

moduleItems :: {[ModuleItem]}
moduleItems : moduleItems                   { [$1] }
            | moduleItem "\n" moduleItems  { $1 : $3 }

moduleItem :: {ModuleItem}
moduleItem : functionDef    { FunctionItem $1 (getPos $1) }

functionDef :: {FunctionDef}
functionDef : functionSignature "{" bodyStructures "}"

functionSignature :: {FunctionSignature}
functionSignature : -- TODO: This... and everything else lol

exprList :: {[Expr]}
exprList : {- empty -}          { [] }
         | exprListNonZero      { $1 }

exprListNonZero :: {[Expr]}
exprListNonZero : expr                      { [$1] }
                | expr "," exprListNonZero  { $1 : $3 }

maybe(p) : {- empty -} { Nothing }
         | p           { Just $1 }

{

parseError :: Token -> Alex a
parseError t = case t of
    TEoF -> alexError $ "Unexpected EoF"
    t' -> case position t' of
        AlexPn _ l c -> alexError $ show l ++ ":" ++ show c ++ ": " ++ "Parse error on " ++ show t

resolveTuple :: [SpadeType] -> SpadeType
resolveTuple [] = error "The impossible has happened, you seem to have an expression with no type, not even the unit?"
resolveTuple [t] = t
resolveTuple ts = ETuple ts

}
