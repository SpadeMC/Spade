{
{-|
Module      : SpadeParser
Description : Parser for Spade
Copyright   : (c) Josh Findon and Edward Jones, 2019
License     : MIT
Maintainer  : Josh Findon and Edward Jones
Stability   : experimental
Portability : POSIX + Windows
Language    : Haskell2010

This module defines the machinery to parse Spade from a token stream generated by the lexer.
-}
module Language.SpadeParser (parseSpade) where

import Language.AST
import Language.SpadeLexer (Alex, AlexPosn(..), Token(..), lexWrap, alexError, runAlex)
import Language.Position (GetPos, getPos)

}

%name parseSpade ast
%name parseREPL moduleItem

%error { parseError }
%lexer { lexWrap } { TEoF }
%monad { Alex }
%tokentype { Token }

-- Enforce perfection
%expect 0

%token
    BOOL            { TBool                 isTrue p }
    IDENT           { TIdent                identifierVal p }
    INT             { TInteger              intVal p }
    REAL            { TReal                 realVal p }
    STRING          { TString               stringVal p }
    LINE_COMMENT    { TLineComment          p }
    ":"             { TColon                p }
    "}"             { TBlockSeparator       p }
    "{"             { TBlockStarter         p }
    "\n"            { TPartSeparator        p }
    "("             { TLParenth             p }
    ")"             { TRParenth             p }
    "["             { TLBracket             p }
    "]"             { TRBracket             p }
    ".."            { TRange                p }
    ","             { TComma                p }
    "."             { TDot                  p }
    "|"             { TSeqCont              p }
    "|-"            { TSeqSeries            p }
    "|>"            { TSeqStart             p }
    "bool"          { TBoolT                p }
    "real"          { TRealT                p }
    "int"           { TIntT                 p }
    "string"        { TStringT              p }
    "case"          { TCase                 p }
    "else"          { TElse                 p }
    "if"            { TIf                   p }
    "for"           { TFor                  p }
    "in"            { TIn                   p }
    "repeat"        { TRepeat               p }
    "while"         { TWhile                p }
    "return"        { TReturn               p }
    "="             { TGets                 p }
    "<=="           { TNBTMove              p }
    "><"            { TSwap                 p }
    "$"             { TConstant             p }
    "~"             { TPure                 p }
    "->"            { TGoesTo               p }
    "=="            { TEqual                p }
    "!="            { TNotEqual             p }
    "<"             { TLAngle               p }
    "<"             { TLessThan             p }
    "<="            { TLessThanOrEqual      p }
    ">"             { TGreaterThan          p }
    ">="            { TGreaterThanOrEqual   p }
    ">"             { TRAngle               p }
    "/"             { TMax                  p }
    "/"             { TMin                  p }
    "&"             { TAnd                  p }
    "!"             { TNot                  p }
    "|"             { TOr                   p }
    "/"             { TCommand              p }
    "/"             { TDivide               p }
    "+"             { TPlus                 p }
    "-"             { TMinus                p }
    "*"             { TTimes                p }
    "%"             { TModulo               p }

%left CALL
%right "->"
%left "|"
%left "&"
%left "==" "!="
%left "<" "<=" ">" ">="
%left "+" "-"
%left "*" "/" "%"
%right NEG "!"
%right "$" "~"
%nonassoc "{" "[" "(" INT REAL CHAR BOOL IDENT STRING

%%

ast :: {AST}
ast : moduleItems   { AST $1 }

moduleItems :: {[ModuleItem]}
moduleItems : moduleItems                   { [$1] }
            | moduleItem "\n" moduleItems  { $1 : $3 }

moduleItem :: {ModuleItem}
moduleItem : functionDef    { FunctionItem $1 (getPos $1) }

functionDef :: {FunctionDef}
functionDef : functionSignature "{" bodyStructures "}"

functionSignature :: {FunctionSignature}
functionSignature : -- TODO: This... and everything else lol

exprList :: {[Expr]}
exprList : {- empty -}          { [] }
         | exprListNonZero      { $1 }

exprListNonZero :: {[Expr]}
exprListNonZero : expr                      { [$1] }
                | expr "," exprListNonZero  { $1 : $3 }

maybe(p) : {- empty -} { Nothing }
         | p           { Just $1 }

{

parseError :: Token -> Alex a
parseError t = case t of
    TEoF -> alexError $ "Unexpected EoF"
    t' -> case position t' of
        AlexPn _ l c -> alexError $ show l ++ ":" ++ show c ++ ": " ++ "Parse error on " ++ show t

resolveTuple :: [SpadeType] -> SpadeType
resolveTuple [] = error "The impossible has happened, you seem to have an expression with no type, not even the unit?"
resolveTuple [t] = t
resolveTuple ts = ETuple ts

}
